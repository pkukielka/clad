/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef TranslationUnit_TYPES_H
#define TranslationUnit_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include "Types_types.h"
#include "Index_types.h"


namespace clad {

struct CXTranslationUnit_Flags {
  enum type {
    CXTranslationUnit_None = 0,
    CXTranslationUnit_DetailedPreprocessingRecord = 1,
    CXTranslationUnit_Incomplete = 2,
    CXTranslationUnit_PrecompiledPreamble = 4,
    CXTranslationUnit_CacheCompletionResults = 8,
    CXTranslationUnit_ForSerialization = 16,
    CXTranslationUnit_CXXChainedPCH = 32,
    CXTranslationUnit_SkipFunctionBodies = 64,
    CXTranslationUnit_IncludeBriefCommentsInCodeCompletion = 128
  };
};

extern const std::map<int, const char*> _CXTranslationUnit_Flags_VALUES_TO_NAMES;

struct CXSaveTranslationUnit_Flags {
  enum type {
    CXSaveTranslationUnit_None = 0
  };
};

extern const std::map<int, const char*> _CXSaveTranslationUnit_Flags_VALUES_TO_NAMES;

struct CXSaveError {
  enum type {
    CXSaveError_None = 0,
    CXSaveError_Unknown = 1,
    CXSaveError_TranslationErrors = 2,
    CXSaveError_InvalidTU = 3
  };
};

extern const std::map<int, const char*> _CXSaveError_VALUES_TO_NAMES;

struct CXReparse_Flags {
  enum type {
    CXReparse_None = 0
  };
};

extern const std::map<int, const char*> _CXReparse_Flags_VALUES_TO_NAMES;

struct CXTUResourceUsageKind {
  enum type {
    CXTUResourceUsage_AST = 1,
    CXTUResourceUsage_Identifiers = 2,
    CXTUResourceUsage_Selectors = 3,
    CXTUResourceUsage_GlobalCompletionResults = 4,
    CXTUResourceUsage_SourceManagerContentCache = 5,
    CXTUResourceUsage_AST_SideTables = 6,
    CXTUResourceUsage_SourceManager_Membuffer_Malloc = 7,
    CXTUResourceUsage_SourceManager_Membuffer_MMap = 8,
    CXTUResourceUsage_ExternalASTSource_Membuffer_Malloc = 9,
    CXTUResourceUsage_ExternalASTSource_Membuffer_MMap = 10,
    CXTUResourceUsage_Preprocessor = 11,
    CXTUResourceUsage_PreprocessingRecord = 12,
    CXTUResourceUsage_SourceManager_DataStructures = 13,
    CXTUResourceUsage_Preprocessor_HeaderSearch = 14,
    CXTUResourceUsage_MEMORY_IN_BYTES_BEGIN = 1,
    CXTUResourceUsage_MEMORY_IN_BYTES_END = 14,
    CXTUResourceUsage_First = 1,
    CXTUResourceUsage_Last = 14
  };
};

extern const std::map<int, const char*> _CXTUResourceUsageKind_VALUES_TO_NAMES;

typedef  ::clad::ResourceId CXTranslationUnit;

typedef struct _CXUnsavedFile__isset {
  _CXUnsavedFile__isset() : Filename(false), Contents(false) {}
  bool Filename;
  bool Contents;
} _CXUnsavedFile__isset;

class CXUnsavedFile {
 public:

  static const char* ascii_fingerprint; // = "07A9615F837F7D0A952B595DD3020972";
  static const uint8_t binary_fingerprint[16]; // = {0x07,0xA9,0x61,0x5F,0x83,0x7F,0x7D,0x0A,0x95,0x2B,0x59,0x5D,0xD3,0x02,0x09,0x72};

  CXUnsavedFile() : Filename(), Contents() {
  }

  virtual ~CXUnsavedFile() throw() {}

  std::string Filename;
  std::string Contents;

  _CXUnsavedFile__isset __isset;

  void __set_Filename(const std::string& val) {
    Filename = val;
  }

  void __set_Contents(const std::string& val) {
    Contents = val;
  }

  bool operator == (const CXUnsavedFile & rhs) const
  {
    if (!(Filename == rhs.Filename))
      return false;
    if (!(Contents == rhs.Contents))
      return false;
    return true;
  }
  bool operator != (const CXUnsavedFile &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CXUnsavedFile & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(CXUnsavedFile &a, CXUnsavedFile &b);

typedef struct _CXTUResourceUsageEntry__isset {
  _CXTUResourceUsageEntry__isset() : kind(false), amount(false) {}
  bool kind;
  bool amount;
} _CXTUResourceUsageEntry__isset;

class CXTUResourceUsageEntry {
 public:

  static const char* ascii_fingerprint; // = "6E7DD25E88B43484CFC93FCB15DCA1AF";
  static const uint8_t binary_fingerprint[16]; // = {0x6E,0x7D,0xD2,0x5E,0x88,0xB4,0x34,0x84,0xCF,0xC9,0x3F,0xCB,0x15,0xDC,0xA1,0xAF};

  CXTUResourceUsageEntry() : kind((CXTUResourceUsageKind::type)0), amount(0) {
  }

  virtual ~CXTUResourceUsageEntry() throw() {}

  CXTUResourceUsageKind::type kind;
   ::clad::u64 amount;

  _CXTUResourceUsageEntry__isset __isset;

  void __set_kind(const CXTUResourceUsageKind::type val) {
    kind = val;
  }

  void __set_amount(const  ::clad::u64 val) {
    amount = val;
  }

  bool operator == (const CXTUResourceUsageEntry & rhs) const
  {
    if (!(kind == rhs.kind))
      return false;
    if (!(amount == rhs.amount))
      return false;
    return true;
  }
  bool operator != (const CXTUResourceUsageEntry &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CXTUResourceUsageEntry & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(CXTUResourceUsageEntry &a, CXTUResourceUsageEntry &b);

typedef struct _CXTUResourceUsage__isset {
  _CXTUResourceUsage__isset() : entries(false) {}
  bool entries;
} _CXTUResourceUsage__isset;

class CXTUResourceUsage {
 public:

  static const char* ascii_fingerprint; // = "03821A51CA7A94FCEDF0645AB86FBAC4";
  static const uint8_t binary_fingerprint[16]; // = {0x03,0x82,0x1A,0x51,0xCA,0x7A,0x94,0xFC,0xED,0xF0,0x64,0x5A,0xB8,0x6F,0xBA,0xC4};

  CXTUResourceUsage() {
  }

  virtual ~CXTUResourceUsage() throw() {}

  std::vector<CXTUResourceUsageEntry>  entries;

  _CXTUResourceUsage__isset __isset;

  void __set_entries(const std::vector<CXTUResourceUsageEntry> & val) {
    entries = val;
  }

  bool operator == (const CXTUResourceUsage & rhs) const
  {
    if (!(entries == rhs.entries))
      return false;
    return true;
  }
  bool operator != (const CXTUResourceUsage &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CXTUResourceUsage & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(CXTUResourceUsage &a, CXTUResourceUsage &b);

} // namespace

#endif
